<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>ImageNet Viewer</title>
    <style>
      :root { color-scheme: light dark; }
      body { font-family: system-ui, Segoe UI, Roboto, Helvetica, Arial, sans-serif; margin: 0; }
      header { padding: 12px 16px; border-bottom: 1px solid #ccc; position: sticky; top: 0; background: rgba(250,250,250,.9); backdrop-filter: blur(6px); }
      main { padding: 12px 16px; }
      .search { display: flex; gap: 8px; align-items: center; }
      .search input { flex: 1; padding: 8px 10px; font-size: 14px; }
      .tree { margin-top: 12px; }
      ul { list-style: none; margin: 0; padding-left: 18px; }
      .node { display: flex; align-items: center; gap: 6px; padding: 2px 0; }
      .toggle { cursor: pointer; width: 1em; display: inline-flex; align-items: center; justify-content: center; }
      .title { cursor: default; }
      .badge { font-size: 11px; opacity: .7; }
      .loading { opacity: .6; font-style: italic; }
      .muted { opacity: .6; }
      .empty { padding: 6px 2px; opacity: .7; }
      .footer { margin-top: 24px; font-size: 12px; opacity: .7; }
      @media (prefers-color-scheme: dark){ header{border-bottom-color:#444} }
    </style>
  </head>
  <body>
    <header>
      <div class="search">
        <input id="search" type="text" placeholder="Search titles (e.g. 'goldenrod') — results show only nodes whose titles contain the term" />
        <button id="clearBtn" title="Clear">Clear</button>
      </div>
    </header>
    <main>
      <div id="app"></div>
      <div class="footer muted">Data loads lazily. In search mode, only nodes whose Title contains your term are shown.</div>
    </main>

    <!-- React via CDN for simplicity -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>

    <script type="text/babel">
      const { useState, useEffect, useMemo, useCallback, useRef } = React;

      function useDebounced(value, delay = 350){
        const [debounced, setDebounced] = useState(value);
        useEffect(() => {
          const id = setTimeout(() => setDebounced(value), delay);
          return () => clearTimeout(id);
        }, [value, delay]);
        return debounced;
      }

      async function fetchJson(url){
        const res = await fetch(url, { headers: { 'Accept': 'application/json' } });
        if(!res.ok) throw new Error('Request failed: ' + res.status);
        return res.json();
      }

      function makeQuery(params){
        const sp = new URLSearchParams();
        Object.entries(params).forEach(([k,v]) => {
          if(v !== undefined && v !== null && v !== '') sp.append(k, v);
        });
        return sp.toString();
      }

      // Renders `text` with occurrences of `term` wrapped into <mark> elements (case-insensitive)
      function HighlightedText({ text, term }){
        const t = String((text !== null && text !== undefined) ? text : '');
        const q = String((term !== null && term !== undefined) ? term : '').trim();
        if (!q) return t;
        const escapeRegExp = (s) => s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        try {
          const re = new RegExp(`(${escapeRegExp(q)})`, 'ig');
          const parts = t.split(re);
          if (parts.length === 1) return t;
          return (
              parts.map((part, i) => (
                i % 2 === 1 ? <mark key={i}>{part}</mark> : <React.Fragment key={i}>{part}</React.Fragment>
              ))
          );
        } catch (e) {
          // On any regex issue, just render plain text
          return t;
        }
      }

      function TreeNode({ node, loadChildren, searchTerm, autoExpand = false }){
        const [expanded, setExpanded] = useState(false);
        const [loading, setLoading] = useState(false);
        const [children, setChildren] = useState(null); // null = not loaded, [] = loaded no children
        const [hasError, setHasError] = useState('');

        const hasChildren = children ? children.length > 0 : true; // assume expandable until known empty

        const onToggle = async () => {
          if (!expanded) {
            if (children === null) {
              setLoading(true); setHasError('');
              try {
                const items = await loadChildren(node);
                setChildren(items);
              } catch (e){
                setHasError(String(e));
              } finally {
                setLoading(false);
              }
            }
            setExpanded(true);
          } else {
            setExpanded(false);
          }
        };

          // Auto-expand and load this node once if requested (for root element on initial page load)
          useEffect(() => {
            if (autoExpand && !expanded && children === null && !loading) {
              (async () => {
                setLoading(true); setHasError('');
                try {
                  const items = await loadChildren(node);
                  setChildren(items);
                  setExpanded(true);
                } catch (e){
                  setHasError(String(e));
                } finally {
                  setLoading(false);
                }
              })();
            }
          }, [autoExpand, expanded, children, loading, loadChildren, node]);

        return (
          <li>
            <div className="node">
              <span className="toggle" onClick={onToggle} title={expanded ? 'Collapse' : 'Expand'}>
                {hasChildren ? (expanded ? '▼' : '▶') : '•'}
              </span>
              <span className="title" title={node.Name}>
                <HighlightedText text={node.title} term={searchTerm} />
              </span>
              {loading && <span className="loading">Loading…</span>}
              {!!node.Size && <span className="badge">{node.Size}</span>}
            </div>
            {hasError && <div className="empty">Error: {hasError}</div>}
            {expanded && children && children.length > 0 && (
              <ul>
                {children.map(child => (
                  <TreeNode key={child.id} node={child} loadChildren={loadChildren} searchTerm={searchTerm} />
                ))}
              </ul>
            )}
            {expanded && children && children.length === 0}
          </li>
        );
      }

      function App(){
        const [rootItems, setRootItems] = useState([]);
        const [loadingRoot, setLoadingRoot] = useState(true);
        const [errorRoot, setErrorRoot] = useState('');
        const [search, setSearch] = useState('');
        const debouncedSearch = useDebounced(search, 350);
        // Cache for search results per term to avoid repeated `/image-net-search` fetches.
        // key: term (string), value: { all: full array from `/image-net-search?searchTerm=term`, groups: synthetic root nodes grouped by first segment of Name }
        const searchRootCache = useRef(new Map());

        const isSearching = debouncedSearch.trim().length > 0;

        // ---- Helpers for search grouping by path segments ----
        const NAME_DELIM = ' > ';
        const startsWithPath = (full, path) => full === path || full.startsWith(path + NAME_DELIM);
        const getFirstSegment = (name) => (name || '').split(NAME_DELIM)[0] || '';
        const getImmediateChildSegments = (items, prefix) => {
          const segs = new Set();
          const lookFor = prefix + NAME_DELIM;
          for (const n of items) {
            const nm = n.Name || n.name || '';
            if (nm.startsWith(lookFor)) {
              const rest = nm.slice(lookFor.length);
              const seg = rest.split(NAME_DELIM)[0];
              if (seg) segs.add(seg);
            }
          }
          return Array.from(segs);
        };
        const findExactByName = (items, fullPath) => items.find(n => (n.Name === fullPath) || (n.name === fullPath));
        const aggregateSizeForPath = (items, path) => {
          let total = 0;
          for (const n of items) {
            const nm = n.Name || n.name || '';
            if (startsWithPath(nm, path)) {
              const s = typeof n.Size === 'number' ? n.Size : 0;
              total += s;
            }
          }
          return total;
        };
        const makeSyntheticNode = (fullPath, level) => {
          const title = fullPath;
          return {
            id: `group:${fullPath}`,
            name: fullPath,
            title,
            // Uppercase duplicates used elsewhere in UI (tooltip)
            Name: fullPath,
            Title: title,
            Level: level,
            ParentId: null,
            isSynthetic: true,
          };
        };

        const buildRootGroups = (allItems) => {
          // Distinct first segments of Name become root synthetic nodes
          const segSet = new Set(allItems.map(n => getFirstSegment(n.Name || n.name || '')));
          segSet.delete('');
          const groups = Array.from(segSet).sort().map(seg => {
            const node = makeSyntheticNode(seg, 1);
            const size = aggregateSizeForPath(allItems, seg);
            if (size) node.Size = size;
            return node;
          });
          return groups;
        };

        const loadRoot = useCallback(async (term) => {
          setLoadingRoot(true); setErrorRoot('');
          try {
            if (term) {
              // Try use cached search results for this term (uses full response remembered for reuse)
              const cached = searchRootCache.current.get(term);
              if (cached) {
                // Use precomputed synthetic root groups
                setRootItems(cached.groups || buildRootGroups(cached.all || []));
                return;
              }
              const q = makeQuery({ searchTerm: term });
              const data = await fetchJson(`/image-net-search?${q}`);
              // Build synthetic root groups by first segment of Name
              const groups = buildRootGroups(data);
              setRootItems(groups);
              // remember the WHOLE response and groups for subsequent same-term loads
              searchRootCache.current.set(term, { all: data, groups });
            } else {
              const q = makeQuery({ maxDepth: 1 });
              const data = await fetchJson(`/image-net?${q}`);
              setRootItems(data);
            }
          } catch (e){
            setErrorRoot(String(e));
          } finally {
            setLoadingRoot(false);
          }
        }, []);

        useEffect(() => { loadRoot(debouncedSearch.trim()); }, [loadRoot, debouncedSearch]);

        const loadChildren = useCallback(async (parent) => {
          const parentPath = parent.Name || parent.name || null;
          if (isSearching) {
            const term = debouncedSearch.trim();
            const cached = searchRootCache.current.get(term);
            const computeChildrenFrom = async (items) => {
              if (parent.isSynthetic) {
                // Build children by next path segment under parentPath
                const segs = getImmediateChildSegments(items, parentPath);
                const children = segs.map(seg => {
                  const full = parentPath + NAME_DELIM + seg;
                  const real = findExactByName(items, full);
                  if (real) {
                    // Ensure lowercase fields used by UI exist
                    return {
                      ...real,
                      id: real.id,
                      name: real.name,
                      title: real.title,
                    };
                  }
                  const syn = makeSyntheticNode(full, (parent.Level || 0) + 1);
                  // For synthetic children, show only the trailing segment as title
                  const lastSeg = full.split(NAME_DELIM).pop();
                  syn.title = lastSeg;
                  syn.Title = lastSeg;
                  const size = aggregateSizeForPath(items, full);
                  if (size) syn.Size = size;
                  return syn;
                });
                return children;
              }

              const q = makeQuery({ nodePath: parentPath, maxDepth: 1 });
              return await fetchJson(`/image-net?${q}`);
            };

            if (cached && cached.all) {
              return computeChildrenFrom(cached.all);
            }

            // Fallback: fetch scoped results
            const q = makeQuery({ nodePath: parentPath, searchTerm: term });
            const data = await fetchJson(`/image-net-search?${q}`);
            return computeChildrenFrom(data);
          } else {
            if (parentPath) {
              const q = makeQuery({ nodePath: parentPath, maxDepth: 1 });
              return await fetchJson(`/image-net?${q}`);
            } else {
              // root children without search handled by loadRoot
              const q = makeQuery({ maxDepth: 1 });
              return await fetchJson(`/image-net?${q}`);
            }
          }
        }, [isSearching, debouncedSearch]);

        useEffect(() => {
          const input = document.getElementById('search');
          const clearBtn = document.getElementById('clearBtn');
          const onInput = (e) => setSearch(e.target.value);
          const onClear = () => setSearch('');
          input.addEventListener('input', onInput);
          clearBtn.addEventListener('click', onClear);
          return () => { input.removeEventListener('input', onInput); clearBtn.removeEventListener('click', onClear); };
        }, []);

        return (
          <div className="tree">
            {loadingRoot && <div className="loading">Loading…</div>}
            {errorRoot && <div className="empty">Error: {errorRoot}</div>}
            {!loadingRoot && !errorRoot && rootItems.length === 0 && (
              <div className="empty">No results</div>
            )}
            {!loadingRoot && !errorRoot && rootItems.length > 0 && (
              <ul>
                {rootItems.map(n => (
                  <TreeNode
                    key={n.id}
                    node={n}
                    loadChildren={loadChildren}
                    searchTerm={debouncedSearch.trim()}
                    autoExpand={!isSearching && rootItems.length === 1}
                  />
                ))}
              </ul>
            )}
          </div>
        );
      }

      const root = ReactDOM.createRoot(document.getElementById('app'));
      root.render(<App />);
    </script>
  </body>
  </html>